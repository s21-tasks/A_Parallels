# Parallels

Реализация проекта Parallels.


## Contents

1. [Chapter I](#chapter-i) \
    1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) \
    2.1. [Многопоточность](#многопоточность) \
    2.2. [Мьютексы](#мьютексы) \
    2.3. [Метод конвейерного параллелизма](#метод-конвейерного-параллелизма)
3. [Chapter III](#chapter-iii) \
    3.1. [Part 1](#part-1-муравьиный-алгоритм)  \
    3.2. [Part 2](#part-1-решение-слау)  \
    3.3. [Part 3](#part-1-алгоритм-винограда) 


## Chapter I

## Introduction

В данном проекте вам предстоит ознакомиться с основными подходами к параллелизму, а также реализовать некоторые алгоритмы с его применением.


## Chapter II

### Многопоточность

**Синхронная программная модель** – это программная модель, в рамках которой каждому потоку назначается набор задач. 
Все задачи в рамках потока выполняются последовательно друг за другом, когда завершено выполнение одной задачи, появляется возможность заняться другой. 
В этой модели невозможно останавливать выполнение задачи, чтобы в промежутке выполнить другую задачу.

Частным случаем синхронной модели является *однопоточность*. Если имеется несколько задач, которые надлежит выполнить, и текущая система предоставляет один поток, который может работать со всеми задачами, то он берет поочередно одну за другой и процесс выглядит так:

![singlethreaded](misc/images/singlethreaded.png)

Здесь видно, что имеется поток и 4 задачи, которые необходимо выполнить. 
Поток начинает выполнять поочередно одну за одной и выполняет их в итоге все. 

В случаях, когда порядок, в котором задачи выполняются, не влияет на результат работы программы, может быть применена *многопоточность*.

Многопоточность является другим случаем синхронной модели – в этом сценарии, используются много потоков, которые могут брать задачи и приступать к работе с ними, т.е. у нас есть пулы потоков и множество задач. \
Итак, многопоточность может работать вот так:

![multithreaded](misc/images/multithreaded.png)

Здесь можно видеть, что у нас есть 4 потока и столько же задач для выполнения, и каждый поток начинает работать с ними. 
Это идеальный сценарий, но в обычных условиях используется большее количество задач чем количество доступных потоков, таким образом освободившийся поток получает другое задание. \
Нежелательно каждый раз создавать новые потоки, потому что для этого требуется использование дополнительных системных ресурсов, таких как процессорное время, память. Поэтому изначальное количество потоков должно быть заранее заданным.

### Мьютексы

При написании многопоточных приложений почти всегда требуется работать с общими данными, одновременное изменение которых может привести к очень неприятным последствиям.
Для блокировки общих данных от одновременного доступа необходимо использовать *объекты синхронизации*.

**Мьютекс** представляет собой взаимно исключающий синхронизирующий объект. 
Это означает, что он может быть получен потоком только по очереди. 
Мьютекс предназначен для тех ситуаций, в которых общий ресурс может быть одновременно использован только в одном из потоков. 
Допустим, что системный журнал совместно используется в нескольких процессах, но только в одном из них данные могут записываться в файл этого журнала в любой момент времени. 
Для синхронизации процессов в данной ситуации идеально подходит мьютекс.

Для описания мьютекса требуется всего один бит, хотя чаще используется целая переменная, у которой 0 означает неблокированное состояние, а все остальные значения соответствуют блокированному состоянию. 
Значение мьютекса устанавливается двумя процедурами: захвата и освобождения.
1. Если поток собирается войти в критическую область, он вызывает процедуру захвата. 
2. Если мьютекс не заблокирован, запрос выполняется и вызывающий поток может попасть в критическую область. 
3. Если mutex закрыт, то поток пытающийся войти в критическую секцию блокируется.
4. Если поток собирается выйти из критической области, он, соответственно, вызывает процедуру освобождения.

Принципы работы с мьютексами отличаются в Windows и Linix, но в общем случае можно выделить следующие шаги:
- Создание/Описание
- Открытие/Инициализация
- Попытка захвата и ожидание
- Освобождение

### Метод конвейерного параллелизма

Классическим способом применения многопоточности, в случае, когда необходимо решить одну и ту же задачу для некоторого количества *N* наборов исходных данных, является запуск всего алгоритма в одном потоке. 
При таком подходе каждым потоком алгоритм выполняется для *N/(число_потоков)* наборов исходных данных.

**Конвейеризация** (или конвейерная обработка) в общем случае основана на разделении подлежащего исполнению алгоритма на более мелкие части, называемые ступенями, и выделении для каждой из них отдельного потока. 
Так обработку любого набора данных можно разделить на несколько этапов, организовав передачу данных от одного этапа к следующему. 
Производительность при этом возрастает благодаря тому, что на различных ступенях (в разных потоках) конвейера одновременно обрабатываются разные наборы данных. 

Пример организации работы конвейера:

![conveyor](misc/images/conveyor.png)

В качестве конкретного примера можно привести алгоритм поиска наибольшего числа в строке. 
На вход подается массив строк, для каждой из которых нужно выполнить поиск. 
В первом потоке будет выполняться разбиение строки на слова, во втором приведение слов к числовому типу данных, в третьем поиск наибольшего среди чисел. 
И тогда процесс работы будет выглядеть так:
1. В первом потоке обрабатывается 1-я строка из массива. Остальные строки ожидают своей очереди.
2. Массив слов, полученный после обработки 1-й строки поступает на обработку во 2-й поток. Так как первой поток освободился, в него на обработку поступает 2-я строка.
3. Далее переход между 2-м и 3-м потоками происходит так же, как и между 1-м и 2-м.
4. В случае, если 2-я строка обработалась в 1-м потоке быстрее, чем 1-я строка во 2-м потоке, 2-я строка поступает в очередь ожидающих освобождения 2-го потока. Тем временем, так как первой поток освободился, в него на обработку поступает 3-я строка.


## Chapter III

## Part 1. Муравьиный алгоритм

Необходимо реализовать муравьиный алгоритм для решения задачи коммивояжера из прошлого задания *A2_SimpleNavigator* с применением параллельных вычислений и без них:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Предусмотреть Makefile для сборки библиотеки и тестов (с целями all, clean, ant)
- У программы должен быть предусмотрен консольный интерфейс
- Пользователем задается матрица для задачи коммивояжера
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов для указанной матрицы
- Измерить время, которое потребуется для выполнения *N* раз муравьиного алгоритма с применением параллелизма для заданной пользователем матрицы
- Измерить время, которое потребуется для выполнения *N* раз обычного муравьиного алгоритма для заданной пользователем матрицы
- На экран вывести полученные времена
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

## Part 2. Решение СЛАУ

Необходимо реализовать обычный и параллельный алгоритмы решения СЛАУ методом Гаусса:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Предусмотреть Makefile для сборки библиотеки и тестов (с целями all, clean, gauss)
- У программы должен быть предусмотрен консольный интерфейс
- Пользователем задается матрица, описывающая СЛАУ
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов для указанной СЛАУ
- Измерить время, которое потребуется для выполнения *N* раз параллельного алгоритма решения заданной пользователем СЛАУ
- Измерить время, которое потребуется для выполнения *N* раз обычного алгоритма решения заданной пользователем СЛАУ
- Вывести на экран полученные времена
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

## Part 3. Алгоритм Винограда

Необходимо реализовать алгоритм Винограда умножения матриц без применения параллелизма, а также с использованием конвейерного и классического способов параллелизма:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Предусмотреть Makefile для сборки библиотеки и тестов (с целями all, clean, winograd)
- Должно быть выделено 4 стадии работы конвейера
- У программы должен быть предусмотрен консольный интерфейс
- Должно быть предусмотрено 2 способа ввода:
    - Пользователем задаются обе матриц для умножения
    - Пользователем задаются размерности матриц, которые затем заполняются в программе случайным образом
- Пользователем задается кол-во выполнений *N*
- Вывести на экран результаты работы каждого из алгоритмов, а также сгенерированные матрицы
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц без применения параллелизма
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц с применением классического параллелизма при количестве потоков, равном 2, 4, 8, ..., 4 * (число логических процессоров компьютера)
- Измерить время, которое потребуется для выполнения *N* раз перемножения матриц с применением конвейерного параллелизма
- Вывести на экран полученные времена
- Для блокировки доступа к данным при параллельной реализации, использовать мьютексы

